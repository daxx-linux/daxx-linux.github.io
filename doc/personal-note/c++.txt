多态按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。

C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。

虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。

我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。



上面的代码会捕获一个类型为 ExceptionName 的异常。如果您想让 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号 ...，如下所示：
try
{
   // 保护代码
}catch(...)
{
  // 能处理任何异常的代码
}
======================================================================
子类和父类中的同名函数，参数不同：
	父类中有virtual
		父类函数被隐藏，子类无法调用
	父类中无virtual
		父类函数被隐藏，子类无法调用

子类和父类中的同名函数，参数相同：
	父类中有virtual
		子类重写父类函数
	父类中无virtual
		父类函数被隐藏，子类无法调用
	
======================================================
想同时使用子类和父类中的同名函数，可以在子类中加作用域：
using Parent::fun;


===========================================================
 vector的clear方法注意事项

　　void clear()：删除存储在vector中的所有元素

一、

　　1.如果vector的元素是一些object，则它将为当前存储的每个元素调用它们各自的析构函数。

　　2.如果vector存储的是指向对象的指针，此函数并不会调用到对应的析构函数。会造成内存泄漏。想要删除vector中的元素则应遍历vector使用delete，然后再clear

　　for(int i = 0; i < vec.size(); ++i)

　　{

　　　　delete vec[i];

　　}

　　vec.clear();

　　调用clear后，vector的size将变成0，但是它的容量capacity并未发生改变，clear只是删除数据，并未释放vector的内存

　　vector的clear不影响capacity

　　如果想要清空vector的元素，使用clear，如果想要释放vector的容量，可以使用swap

二、使用swap释放vector的容量

　　vector<A>().swap(vec);
　　或者vec.swap(vector<A>());
　　重点：如果vector容器的元素是指针，先遍历容器，delete每个元素指向的内存，然后再用swap
https://www.cnblogs.com/vinke2013/p/7209097.html
-----------------------------------------------------------------------
vector capcility:占用空间，size实际使用空间大小，类型sizeof() strlen
https://blog.csdn.net/qq_41929943/article/details/103190891
-----------------------------------------------------------------------